{"title":"Ian's Archives","description":"","language":"en","link":"http://iaaaannn0.com","webMaster":"Ian","pubDate":"Wed, 02 Apr 2025 11:50:08 GMT","lastBuildDate":"Wed, 02 Apr 2025 11:52:36 GMT","generator":"hexo-generator-json-feed","items":[{"title":"GitHub Keywords for Automatically Closing Issues","link":"http://iaaaannn0.com/2025/04/02/GitHub-Keywords-for-Automatically-Closing-Issues/","description":"GitHub supports special keywords that allow issues to be closed automatically when a pull request or commit is merged into the default branch, such as main. This functionality helps maintain cleaner workflows and better issue tracking. Common Keywords for Auto-Closing The following keywords, when used in a pull request description or commit message, will automatically close the referenced issue once the code is merged: ​ • fixes #1 ​ • closes #1 ​ • resolves #1 Example: 1Fixes #42 by updating the caching strategy. Multiple issues can also be referenced in the same statement: 1Closes #5, resolves #7, and fixes #9. Referencing Without Closing To create links between issues and pull requests without triggering auto-close, use general references such as: ​ • Related to #2 ​ • See also: #3 ​ • Blocked by #4 These references do not close any issues but appear in the sidebar for better visibility and traceability. Notes on Behavior ​ • Auto-closing only occurs when the pull request is merged into the default branch. ​ • Keywords must be in the pull request description or the commit message that is part of the merge. ​ • Comments or discussion threads do not trigger automatic closing, even if keywords are present. Summary Using GitHub’s built-in keyword system enhances automation and keeps issue lists up to date with minimal manual intervention. Including the appropriate keywords ensures that completed work is properly tracked and linked.","pubDate":"Wed, 02 Apr 2025 11:50:08 GMT","guid":"http://iaaaannn0.com/2025/04/02/GitHub-Keywords-for-Automatically-Closing-Issues/","category":["github"]},{"title":"Top 10 API Security Vulnerabilities and How to Test Them","link":"http://iaaaannn0.com/2025/02/19/API-Security-Testing/","description":"source 1. Broken Object Level Authorization (BOLA)Description: API users should only be able to access resources that belong to them. When BOLA occurs, users may be able to access resources that don’t belong to them. Example:If an API lets users view their personal information, an attacker might modify the URL from /user/123 to /user/124 to access another user’s information. How to Test:Modify the object identifier in the request URL and check if you can access other users’ data. If unauthorized access is possible, it indicates a BOLA vulnerability. 2. Broken AuthenticationDescription: This occurs when an API’s authentication mechanisms are weak or poorly implemented, allowing attackers to bypass them. Example:A simple username and password-based login system without multi-factor authentication may allow an attacker to guess passwords and gain unauthorized access. How to Test:Attempt to log in with weak passwords or use brute force attacks. Check whether the API enforces strong password policies and multi-factor authentication. 3. Broken Object Property Level AuthorizationDescription: This vulnerability occurs when an API allows users to access properties of an object that they shouldn’t be able to. Example:An API that lets users view their profiles could have a flaw where users can modify parameters in the request (like ?include_salary=true) to access others’ sensitive information, such as salary. How to Test:Test by modifying request parameters to access unauthorized object properties. Ensure sensitive data like salary or private emails cannot be accessed without proper authorization. 4. Unrestricted Resource ConsumptionDescription: APIs may lack resource consumption limits, allowing attackers to overwhelm the system, causing denial of service or service degradation. Example:Uploading large files, like a 100MB video, could consume server resources, leading to downtime or slower responses for legitimate users. How to Test:Upload large files or send numerous requests in a short time and check whether the API enforces proper limits on file size or request frequency. 5. Broken Function Level AuthorizationDescription: This flaw occurs when an API allows users to access functions they are not authorized to use. Example:An API may allow regular users to call administrative functions like deleting or modifying data that only admins should have access to. How to Test:Attempt to access restricted functions by modifying the request or using a lower privilege account. If the system does not enforce proper function-level authorization, it is vulnerable. 6. Unrestricted Access to Sensitive Business FlowsDescription: APIs that expose sensitive business processes, like payment or financial transactions, should have strict access controls. If these processes are improperly protected, unauthorized users may execute actions they shouldn’t. Example:An attacker could call a payment API directly to make unauthorized payments if proper authentication and access controls are missing. How to Test:Test by attempting to execute sensitive business operations (like payments or transfers) without proper authorization. Verify that only authorized users can access these flows. 7. Server Side Request Forgery (SSRF)Description: SSRF vulnerabilities allow attackers to send requests from the server to internal or external resources that they shouldn’t be able to access. Example:An API that accepts a URL parameter might allow an attacker to input an internal service URL (e.g., http://internal-api.local), potentially exposing sensitive internal systems. How to Test:Use tools like Burp Collaborator to inject internal or malicious URLs into the API requests and check if the server accesses them. If it does, SSRF is a vulnerability. 8. Security MisconfigurationDescription: Security misconfigurations occur when an API is improperly set up, leading to vulnerabilities such as exposing sensitive information in error messages or unnecessarily open ports. Example:An API might expose detailed error messages that include stack traces, which attackers can use to identify vulnerabilities in the system. How to Test:Scan the API for unnecessary open ports, exposed debugging information, or detailed error messages that can reveal sensitive information. 9. Improper Inventory ManagementDescription: APIs might expose old or unused endpoints that can be exploited by attackers if not properly managed. Example:An outdated API endpoint might still be active, even though the service no longer uses it. Attackers could exploit it to gain unauthorized access or retrieve sensitive data. How to Test:Check for unused, outdated, or hidden API endpoints that may still be accessible. Verify if the API properly removes or disables old endpoints. 10. Unsafe Consumption of APIsDescription: APIs that fail to properly validate user input are vulnerable to attacks like SQL injection or cross-site scripting (XSS). Example:An API that allows users to submit text input might fail to sanitize the input, allowing an attacker to inject malicious code, such as &lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;. How to Test:Inject malicious scripts or SQL commands into input fields and observe whether the API performs proper input validation. If malicious code is executed, the API is vulnerable. Let’s assume we are testing an e-commerce API that handles user profiles, payment transactions, and inventory management. Our goal is to assess the security posture of the API using various tools and techniques. 1. Broken Object Level Authorization (BOLA)Vulnerability: Users can access resources they shouldn’t. Simulated Scenario: We’re testing whether a user can access the profile data of other users by modifying the user_id in the API endpoint. API Endpoint:GET /user/&#123;user_id&#125; Testing Process: Tool: Postman or Burp Suite Command: First, log in as user123 and retrieve the profile:GET /user/123 Now, try changing the user_id parameter to 124 to see if you can access another user’s profile:GET /user/124 Observation: If you are able to access user 124‘s data without proper authorization, the API has a BOLA vulnerability. Tooling: Burp Suite: Use Burp Suite’s “Repeater” to modify the user_id and test different user IDs. Postman: Manually change the user_id parameter in the request. 2. Broken AuthenticationVulnerability: Weak authentication mechanisms allow attackers to bypass security. Simulated Scenario: We will check if the API allows weak password authentication or if brute force can bypass login. API Endpoint:POST /login Testing Process: Tool: Hydra (for brute force), Burp Suite Command: Use Burp Suite to intercept the login request and try to submit incorrect login credentials. Alternatively, use Hydra for brute-force testing:hydra -l admin -P /path/to/password-list http://localhost:8080 login Observation: If you can successfully authenticate with weak credentials, the API is vulnerable to brute-force or weak password attacks. Tooling: Hydra: A fast password-cracking tool. Burp Suite: Use the Intruder tab for brute-force login attempts. 3. Broken Object Property Level AuthorizationVulnerability: Unauthorized users can access sensitive properties of objects. Simulated Scenario: A user tries to access the salary field of a profile object that they shouldn’t be able to. API Endpoint:GET /profile/&#123;user_id&#125; Testing Process: Tool: Postman or Burp Suite Command: Retrieve the profile details for user 123:GET /profile/123 Attempt to access a hidden or restricted property like salary:GET /profile/123?include_salary=true Observation: If the response includes sensitive information like salary, the API lacks proper property-level authorization checks. Tooling: Postman: Modify the parameters and check if sensitive data can be exposed. Burp Suite: Intercept requests to modify query parameters. 4. Unrestricted Resource ConsumptionVulnerability: No resource consumption limits in place, causing potential denial of service (DoS). Simulated Scenario: We attempt to upload large files to see if the API imposes any size restrictions. API Endpoint:POST /upload Testing Process: Tool: Postman Command: Try uploading large files using Postman:POST /uploadAttach a 100MB or larger file to the request. Observation: If the API does not impose a file size limit, it is vulnerable to resource exhaustion (e.g., denial of service). Tooling: Postman: Use Postman to upload large files and check if the API rejects files that exceed certain sizes. 5. Broken Function Level AuthorizationVulnerability: Users can access functions they are not authorized to. Simulated Scenario: We test whether a regular user can access admin functions like deleting an order. API Endpoint:DELETE /order/&#123;order_id&#125; Testing Process: Tool: Postman Command: First, test with a regular user (non-admin) to see if they can delete an order:DELETE /order/999 Observation: If the regular user is able to delete an order without proper authorization, there is a broken function-level authorization. Tooling: Postman: Send DELETE requests as a regular user to access admin-only functions. 6. Unrestricted Access to Sensitive Business FlowsVulnerability: Unauthorized users can trigger sensitive business operations, like payments. Simulated Scenario: We test whether a user can make unauthorized payments through the API. API Endpoint:POST /payment Testing Process: Tool: Postman Command: Make a payment request without proper authorization (as a non-logged-in user):POST /paymentInclude payment details in the body (amount, recipient). Observation: If the API allows a non-authenticated or unauthorized user to make a payment, it has a vulnerability. Tooling: Postman: Manually test for unauthorized access to sensitive business operations. 7. Server Side Request Forgery (SSRF)Vulnerability: An attacker can cause the server to make unauthorized requests. Simulated Scenario: We will test if the API allows SSRF by submitting a URL that points to an internal resource. API Endpoint:GET /fetch Testing Process: Tool: Burp Suite or Postman Command: Submit a request with an internal URL:GET /fetch?url=http://localhost:8080/internal Observation: If the API fetches internal resources (e.g., database servers, metadata services), it is vulnerable to SSRF. Tooling: Burp Suite: Modify the request to include malicious internal URLs. Postman: Test for SSRF by submitting requests that point to internal services. 8. Security MisconfigurationVulnerability: Poor API configuration exposes sensitive data or vulnerabilities. Simulated Scenario: We check if the API exposes unnecessary information, such as debug data. API Endpoint:GET /error Testing Process: Tool: Burp Suite or any network scanner Command: Trigger an error on the server:GET /errorCheck the response for error details or stack traces. Observation: If sensitive information (like stack traces or internal system details) is exposed, the API is misconfigured. Tooling: Burp Suite: Intercept the error messages to analyze the responses. Network Scanner: Check for exposed open ports or services. 9. Improper Inventory ManagementVulnerability: The API exposes old or unused endpoints that can be exploited. Simulated Scenario: We attempt to access deprecated or hidden API endpoints. API Endpoint:GET /old-api-endpoint Testing Process: Tool: Burp Suite, Postman Command: Try accessing deprecated API endpoints:GET /old-api-endpoint Observation: If the API exposes deprecated endpoints, it could lead to security issues. Ensure old or unused endpoints are disabled. Tooling: Burp Suite: Use the “Spider” tool to discover hidden or unused endpoints. Postman: Manually test for deprecated API versions. 10. Unsafe Consumption of APIsVulnerability: Failure to properly sanitize user inputs, leading to SQL injection or XSS attacks. Simulated Scenario: We test whether the API is vulnerable to XSS or SQL injection attacks. API Endpoint:GET /search Testing Process: Tool: Burp Suite, SQLMap, or Postman Command: Test for SQL injection:GET /search?query=&#39; OR 1=1 -- Test for XSS:GET /search?query=&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt; Observation: If the API executes malicious code or query manipulation, it is vulnerable to SQL injection or XSS. Tooling: SQLMap: Automate SQL injection testing. Postman: Inject XSS payloads. Burp Suite: Intercept and modify inputs to test for injection flaws.","pubDate":"Wed, 19 Feb 2025 12:19:22 GMT","guid":"http://iaaaannn0.com/2025/02/19/API-Security-Testing/","category":["vuls"]},{"title":"Configuring Caddy to Handle Multiple Sites and Automatic SSL with Cloudflare","link":"http://iaaaannn0.com/2025/02/08/Configuring-Caddy-to-Handle-Multiple-Sites-and-Automatic-SSL-with-Cloudflare/","description":"Automatically Obtain SSL Certificates Using Cloudflare DNS PluginInstalling the Cloudflare PluginCaddy supports various DNS validation methods via its plugin system. To use DNS-01 validation with Cloudflare, you need to install the Cloudflare DNS plugin using the caddy add-package command: 1sudo caddy add-package github.com/caddy-dns/cloudflare This command will download and install the Cloudflare DNS plugin, after which it will update the Caddy binary to include the plugin. Once the installation is complete, you’ll be able to use Cloudflare’s API for DNS-01 validation, which avoids challenges caused by Cloudflare’s proxy mode (orange cloud). Configuring Caddyfile for DNS-01 ValidationIn your Caddyfile, configure each site to use Cloudflare for SSL certificate issuance. You can either provide your Cloudflare API Token directly in the Caddyfile or through an environment variable like CLOUDFLARE_API_TOKEN: 1export CLOUDFLARE_API_TOKEN=your_api_token Then, configure your Caddyfile as follows: 12345678910example.com &#123; root * /var/www/example file_server tls cloudflare&#125;blog.example.com &#123; reverse_proxy localhost:3000 tls cloudflare&#125; With this configuration, Caddy will automatically use Cloudflare’s DNS-01 challenge to issue SSL certificates, even if Cloudflare proxy is enabled. Configuring Multiple Sites and Reverse Proxy1. Static Website ConfigurationSuppose you have a static website, example.com, with its files stored under /var/www/example. The configuration in the Caddyfile would look like this: 12345example.com &#123; root * /var/www/example file_server tls cloudflare&#125; This configuration means that when someone accesses example.com, Caddy will serve files from /var/www/example and automatically obtain an SSL certificate for the domain. 2. Reverse Proxy ConfigurationSuppose you have an application running locally (e.g., a blog) on port 3000, and you want Caddy to forward traffic to that application. In your Caddyfile, you would use the reverse_proxy directive like this: 1234blog.example.com &#123; reverse_proxy localhost:3000 tls cloudflare&#125; This configuration will forward all traffic to blog.example.com to your local service running on port 3000. Blocking Direct IP AccessIf you want to prevent users from accessing your website through the server’s IP address and only allow access via the domain name, you can add a rule in your Caddyfile to check the Host header in the request. You can use the respond directive to reject unauthorized access: 123456789101112131415# Block access via IP:80 &#123; respond &quot;Access Denied&quot; 403&#125;example.com &#123; root * /var/www/example file_server tls cloudflare&#125;blog.example.com &#123; reverse_proxy localhost:3000 tls cloudflare&#125; In this configuration: :80 handles all HTTP requests to the IP address and returns a 403 Forbidden response, blocking access. example.com and blog.example.com are properly configured and will allow requests to these domains. This ensures that users can only access the website via the correct domain and prevents direct IP access.","pubDate":"Fri, 07 Feb 2025 20:36:23 GMT","guid":"http://iaaaannn0.com/2025/02/08/Configuring-Caddy-to-Handle-Multiple-Sites-and-Automatic-SSL-with-Cloudflare/","category":["cloudflare","candy"]},{"title":"Efficient Python Project Management with Just","link":"http://iaaaannn0.com/2025/02/07/Efficient-Python-Project-Management-with-Just/","description":"What is just?just is a task runner that allows you to automate repetitive tasks. You define tasks in a Justfile, and instead of remembering long commands, you can simply run just &lt;task&gt; to execute them. This makes project management much simpler. Creating a JustfileTo use just, create a Justfile in the root directory of your project. This file is where you define your tasks. Basic Task DefinitionA Justfile contains one or more tasks. Each task has a name followed by the commands you want to run. 12345# Justfile# Define a task called hellohello: echo &quot;Hello, World!&quot; Explanation: hello: is the task name. echo &quot;Hello, World!&quot; is the command that will run when you invoke this task. Running the TaskOnce you’ve created the Justfile, you can run the task in your terminal by typing: 1just hello You should see the following output: 1Hello, World! Using Variables in TasksYou can define variables in the Justfile and use them in your tasks. Variables are defined simply by assignment. Example:12345678# Justfile# Define a variablename := &quot;Alice&quot;# Define a taskgreet: echo &quot;Hello, &#123;&#123;name&#125;&#125;!&quot; &#123;&#123;name&#125;&#125; will be replaced with the value of the name variable. When you run the task: 1just greet The output will be: 1Hello, Alice! Using Command-Line ArgumentsYou can also pass arguments from the command line to your tasks. This is useful if you want your tasks to be dynamic and change based on input. 12345# Justfile# Task with command-line argumentgreet_name name: echo &quot;Hello, &#123;&#123;name&#125;&#125;!&quot; Now you can run the task and provide a name as an argument: 1just greet_name Bob Output: 1Hello, Bob! Task DependenciesYou can make tasks depend on other tasks. This allows you to chain tasks together, ensuring that one task runs before another. Example:123456789# Justfile# Define a setup tasksetup: echo &quot;Setting up the environment&quot;# Define a build task, which depends on setupbuild: setup echo &quot;Building the project&quot; In this case, running just build will first execute the setup task, and then it will proceed with the build task: 1just build Output: 12Setting up the environmentBuilding the project Conditionals and Loopsjust supports basic conditionals and loops, which you can use to add more logic to your tasks. Conditional Example:123456789# Justfile# Task: Check environmentcheck_env: if test -f &quot;dev.env&quot;; then echo &quot;Development environment detected&quot; else echo &quot;Production environment detected&quot; fi This example checks if the dev.env file exists and prints a message based on whether it’s found. Loop Example:1234567# Justfile# Task: Print numbers from 1 to 5print_numbers: for i in &#123;1..5&#125;; do echo &quot;Number: $i&quot; done Using Just for Python ProjectsIf you have a Python project, you can use just to manage common tasks like running tests, installing dependencies, or running your application. 12345678910111213# Justfile# Task: Install dependenciesinstall: pip install -r requirements.txt# Task: Run the Python scriptrun: python3 app.py# Task: Run unit teststest: pytest tests/ Now, you can run these tasks simply by typing: 123just install # Install dependenciesjust run # Run the Python scriptjust test # Run unit tests Advanced Usage: Skipping TasksYou can skip a task’s execution by prefixing its name with @. This is useful when you want to skip a task in a chain. 1just @install This will skip the install task and proceed with the next task.","pubDate":"Fri, 07 Feb 2025 17:51:09 GMT","guid":"http://iaaaannn0.com/2025/02/07/Efficient-Python-Project-Management-with-Just/","category":["just"]},{"title":"Reproducible Builds with Nix Step by Step Guide","link":"http://iaaaannn0.com/2025/02/07/Reproducible-Builds-with-Nix-Step-by-Step-Guide/","description":"Nix is a powerful package manager that provides reproducible builds, isolated environments, and efficient package management. In this guide, we’ll explore how to use Nix for package management and environment setups. 1. Installing Software Packages with NixTo install software packages, Nix uses the nix-env command. You can install a package with the following command: 1nix-env -i &lt;package-name&gt; For example, to install the hello package, use: 1nix-env -i hello 2. Searching for PackagesYou can search for available packages in the Nix package repository using the following command: 1nix-env -qaP &lt;package-name&gt; For example, to search for packages related to hello: 1nix-env -qaP hello This will list all available packages matching the name hello. 3. Listing Installed PackagesTo see the list of installed packages, use the following command: 1nix-env -q This will display all the currently installed packages on your system. 4. Upgrading Installed PackagesTo upgrade all installed packages to their latest versions, run: 1nix-env -u If you want to upgrade a specific package, for example, hello, you can use: 1nix-env -u hello 5. Removing PackagesIf you no longer need a particular package, you can uninstall it using the nix-env command: 1nix-env -e &lt;package-name&gt; For example, to uninstall hello, use: 1nix-env -e hello 6. Using nix-shell for Isolated EnvironmentsNix provides nix-shell, which allows you to enter an isolated environment with specific dependencies. You can create a shell.nix file to define the environment for a project. Here’s an example of a shell.nix file: 1234567# shell.nixwith import &lt;nixpkgs&gt; &#123;&#125;;stdenv.mkDerivation &#123; name = &quot;hello-env&quot;; buildInputs = [ hello ];&#125; Once the shell.nix file is defined, enter the environment by running: 1nix-shell This will create a shell environment where the hello package and its dependencies are available. 7. Nix Configuration FilesIn Nix, you can use configuration files to manage dependencies and software installation. Here’s an example of how to define a configuration in a Nix file. You can create a configuration file (e.g., default.nix) that specifies the packages to be installed: 1234567# default.nixwith import &lt;nixpkgs&gt; &#123;&#125;;stdenv.mkDerivation &#123; name = &quot;my-environment&quot;; buildInputs = [ vim hello ];&#125; Commenting in Nix Configuration FilesNix allows you to add comments to your configuration files for clarity. Use # to add a comment: 1234567# This is a simple Nix configuration filewith import &lt;nixpkgs&gt; &#123;&#125;;stdenv.mkDerivation &#123; name = &quot;my-environment&quot;; buildInputs = [ vim hello ]; # Install vim and hello package&#125; In this example: with import &lt;nixpkgs&gt;: Imports the Nix Packages collection. stdenv.mkDerivation: Creates a custom environment. buildInputs: Specifies which packages (like vim and hello) to include in the environment.","pubDate":"Thu, 06 Feb 2025 19:53:33 GMT","guid":"http://iaaaannn0.com/2025/02/07/Reproducible-Builds-with-Nix-Step-by-Step-Guide/","category":["nix"]},{"title":"Semantic Versioning for GitHub Releases","link":"http://iaaaannn0.com/2025/02/06/Semantic-Versioning-for-GitHub-Releases/","description":"What is Semantic Versioning (SemVer)?Semantic Versioning (SemVer) is a widely adopted standard for naming software versions. It follows this format: 1MAJOR.MINOR.PATCH For example: 1v1.0.0 Each part of the version number has a specific meaning: MAJOR: Significant changes that break backward compatibility. MINOR: New features that are backward compatible. PATCH: Bug fixes and small improvements that do not change functionality. Examples of Stable Releases: Version Description v1.0.0 First stable release v1.1.0 Adds new features, backward compatible v1.1.1 Bug fix release, backward compatible v2.0.0 Breaking changes introduced Pre-release Versions (Testing Versions)Before an official stable release, you may want to publish a pre-release version for testing purposes. These versions contain experimental features or improvements that need validation. Naming Format for Pre-release Versions:1MAJOR.MINOR.PATCH-identifier.version Identifier Meaning -alpha Internal testing version (unstable) -beta Public testing version (feature-complete but may contain bugs) -rc Release Candidate (nearly stable, final testing) -snapshot Nightly or in-development snapshot Examples of Pre-release Versions: Version Description v1.0.0-alpha.1 First alpha version (internal testing) v1.0.0-beta.2 Second beta version (public testing) v1.0.0-rc.1 First release candidate v1.0.0 Final stable version Other Naming ConventionsIn some cases, you might want to add metadata or build information to the version number. Version Description v1.0.0+build20240205 Includes build metadata (doesn’t affect version sorting) v1.0.0-dev Development version v1.0.0-nightly Nightly build version","pubDate":"Wed, 05 Feb 2025 19:23:00 GMT","guid":"http://iaaaannn0.com/2025/02/06/Semantic-Versioning-for-GitHub-Releases/","category":["releases"]},{"title":"From Setup to Exploitation - A Comprehensive Guide to 2FA Weaknesses","link":"http://iaaaannn0.com/2025/02/05/From-Setup-to-Exploitation-A-Comprehensive-Guide-to-2FA-Weaknesses/","description":"Description of 2FA VulnerabilitiesTwo-Factor Authentication (2FA) is a critical security feature used to provide an additional layer of protection beyond a username and password. However, vulnerabilities in the implementation, setup, or management of 2FA can undermine its effectiveness. 2FA Setup&#x2F;Implementation1. 2FA Secret Cannot Be RotatedIn many systems, once a 2FA secret (e.g., a key or QR code) is generated, it cannot be rotated or updated. This becomes a problem if the secret is ever exposed, as it leaves the account permanently vulnerable. Impact: If the 2FA secret is compromised, the attacker gains long-term access without the user being able to recover. Solution: Always provide users with the option to securely rotate their 2FA secret. Implement a mechanism to invalidate old secrets and ensure the new one is immediately effective. 2. 2FA Secret Remains Obtainable After 2FA Is EnabledA common issue is leaving the 2FA secret accessible after the initial setup. If a user’s QR code or secret key is stored insecurely or remains visible in the user interface, attackers can retrieve it even after 2FA has been enabled. Impact: This allows an attacker to bypass 2FA protections by using the exposed secret. Solution: Remove or obfuscate the 2FA secret immediately after it is set up. Ensure secrets are never logged, stored in plaintext, or exposed in server responses. 3. Logic Bugs in 2FA SetupPoorly designed logic in the 2FA setup process can cause unintended consequences, such as locking users out of their accounts or corrupting existing authentication settings. For example, systems that allow enabling 2FA without proper state validation can create inconsistencies. Impact: Logic errors can cause account damage or allow attackers to exploit weak points in the setup process. Solution: Thoroughly test the 2FA setup process for edge cases, such as interrupted sessions, invalid requests, and duplicated operations. Use state validation mechanisms to prevent unintended behavior. 4. Previously Created Sessions Remain Valid After 2FA ActivationWhen a user enables 2FA, all active sessions should be invalidated. However, many systems fail to do this, leaving old sessions operational. This can allow attackers with access to an existing session to bypass the new 2FA requirement. Impact: Attackers with access to an active session can continue to operate without being prompted for 2FA. Solution: Automatically terminate all active sessions when 2FA is enabled. Notify users of the session termination and give them control over managing active sessions. 5. Enabling 2FA Without Email VerificationSome systems allow users to enable 2FA without verifying their email or identity. This is problematic because attackers who have gained access to an account could enable and misuse 2FA, making it difficult for the legitimate user to regain control. Impact: Attackers can establish control over an account’s 2FA without proper verification, locking out the legitimate user. Solution: Enforce email or identity verification before allowing users to enable 2FA. This ensures only authorized users can modify security settings. 6. IDOR Vulnerabilities Leading to Account TakeoverInsecure Direct Object References (IDOR) in 2FA-related endpoints can be exploited to modify or access another user’s 2FA settings. For example, attackers could manipulate API requests to enable or disable 2FA for other accounts. Impact: Attackers can take over accounts by altering 2FA settings without authorization. Solution: Implement robust access control mechanisms for all 2FA-related API endpoints. Use user-specific identifiers bound to sessions and validate all requests server-side. 2FA Bypass Vulnerabilities: Detailed Steps and Examples1. 2FA Code Leakage in ResponsesIf 2FA codes are sent in responses from the server to the client, attackers can intercept them using tools like proxies (e.g., Burp Suite) or by monitoring logs. Exploit Steps: Initiate a 2FA login request. Use a proxy to inspect the server’s HTTP response. Look for fields containing the current 2FA code in the JSON or HTML response. Example Response: 12345&#123; &quot;status&quot;: &quot;success&quot;, &quot;2fa_code&quot;: &quot;123456&quot;, &quot;message&quot;: &quot;Verification code sent to your device.&quot;&#125; Attack: By capturing the 2fa_code field, an attacker can bypass the need for real-time code input. Mitigation: Never send 2FA codes or sensitive information in server responses. Use one-time codes that are validated server-side without revealing them to the client. 2. Reusing Old 2FA CodesIf old 2FA codes are not invalidated after generating a new one, attackers can reuse previously intercepted codes. Exploit Steps: Capture a valid 2FA code during a login session. Generate a new 2FA code (e.g., by triggering another login attempt). Use the previously captured code instead of the latest one. Example Exploit Code: 123456789101112import requests# Simulate loginlogin_payload = &#123;&quot;username&quot;: &quot;victim&quot;, &quot;password&quot;: &quot;password123&quot;&#125;session = requests.Session()response = session.post(&quot;https://example.com/login&quot;, data=login_payload)# Use old codebypass_payload = &#123;&quot;2fa_code&quot;: &quot;123456&quot;&#125; # Old captured codebypass_response = session.post(&quot;https://example.com/verify-2fa&quot;, data=bypass_payload)print(bypass_response.status_code) # Should return 200 if bypassed Mitigation: Immediately invalidate old codes when new codes are generated. Use nonce-based validation to ensure that only the most recent code is valid. 3. Lack of Rate-Limiting (Brute-Force Attack)Without rate limits, attackers can brute-force 2FA codes by rapidly trying all possible combinations (e.g., 000000 to 999999). Exploit Steps: Write a script to automate code guessing. Continuously send requests until the correct code is found. Example Attack Script: 123456789101112import requestsurl = &quot;https://example.com/verify-2fa&quot;headers = &#123;&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;&#125;for code in range(1000000): # 6-digit codes payload = &#123;&quot;2fa_code&quot;: f&quot;&#123;code:06&#125;&quot;&#125; response = requests.post(url, data=payload, headers=headers) if response.status_code == 200: # Success print(f&quot;Code found: &#123;code:06&#125;&quot;) break Mitigation: Enforce rate-limiting (e.g., 5 attempts per minute per IP). Introduce account lockouts or CAPTCHA after repeated failures. 4. Bypassing 2FA with Null or Blank ValuesSome systems improperly validate 2FA codes, allowing null or blank values to bypass authentication. Exploit Steps: Attempt to submit an empty or invalid 2fa_code field. Check if authentication succeeds despite no valid code. Example Exploit: 123456import requestspayload = &#123;&quot;2fa_code&quot;: &quot;&quot;&#125;response = requests.post(&quot;https://example.com/verify-2fa&quot;, data=payload)print(response.status_code) # 200 indicates successful bypass Mitigation: Validate input server-side to reject null, empty, or default values. Use strict validation checks for format and length (e.g., exactly 6 digits). 5. Misconfigured Session PermissionsIf session management is not properly configured, attackers may bypass 2FA by directly accessing authenticated endpoints without completing 2FA verification. Exploit Steps: Intercept the session token after login but before 2FA verification. Use the session token to access authenticated endpoints. Example Exploit: 12345678910import requests# Assume session token is captured before 2FAsession_token = &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&quot;# Access a protected endpointheaders = &#123;&quot;Authorization&quot;: f&quot;Bearer &#123;session_token&#125;&quot;&#125;response = requests.get(&quot;https://example.com/protected-endpoint&quot;, headers=headers)print(response.status_code) # 200 indicates bypass Mitigation: Mark sessions as “partial” until 2FA is completed. Restrict access to sensitive endpoints until full authentication is confirmed. 6. Referrer Check Bypass with Direct RequestsIf 2FA verification relies on referrer headers, attackers can bypass these checks by crafting direct requests. Exploit Steps: Inspect network traffic for referrer-based verification. Send a crafted HTTP request without the expected referrer. Example Exploit: 123456import requestsheaders = &#123;&quot;Referer&quot;: &quot;https://example.com/legitimate-page&quot;&#125;response = requests.post(&quot;https://example.com/verify-2fa&quot;, headers=headers)print(response.status_code) # Should bypass referrer-based restrictions Mitigation: Avoid relying solely on referrer headers for verification. Use session-bound tokens or other mechanisms to validate request authenticity. 7. Using OAuth for 2FA BypassIf 2FA integration with OAuth is poorly configured, attackers can exploit token exchange mechanisms to bypass 2FA. Exploit Steps: Exploit a misconfigured OAuth endpoint to request access tokens without completing 2FA. Use the token to authenticate directly. Example Exploit: 123456789101112import requests# Request token from misconfigured endpointtoken_response = requests.post(&quot;https://example.com/oauth/token&quot;, data=&#123;&quot;grant_type&quot;: &quot;password&quot;, &quot;username&quot;: &quot;victim&quot;, &quot;password&quot;: &quot;password123&quot;&#125;)access_token = token_response.json().get(&quot;access_token&quot;)# Use the token to bypass 2FAheaders = &#123;&quot;Authorization&quot;: f&quot;Bearer &#123;access_token&#125;&quot;&#125;response = requests.get(&quot;https://example.com/protected-endpoint&quot;, headers=headers)print(response.status_code) # 200 indicates bypass Mitigation: Require 2FA completion before issuing access tokens. Validate tokens for proper authentication scope and origin. Additional Vulnerabilities in 2FA Disabling1. Lack of Log AuditingIf 2FA enable&#x2F;disable actions are not logged properly, attackers can disable 2FA without detection, leaving the user and administrators unaware of the breach. Impact: Attackers can disable 2FA stealthily, making accounts vulnerable. Mitigation: Log all 2FA-related actions, including enabling, disabling, and failed attempts. Include details like timestamps, IP addresses, and user-agent strings in the logs. Code Example: 123456789101112def disable_2fa(user_id): # Perform the 2FA disabling logic perform_disable_2fa(user_id) # Log the action log_action( user_id=user_id, action=&quot;2FA Disabled&quot;, ip_address=get_client_ip(), user_agent=get_user_agent(), timestamp=get_current_timestamp() ) 2. Weak Backup Code SecurityBackup codes are often provided for account recovery if the primary 2FA device is unavailable. If these codes are predictable, insufficiently long, or not invalidated after use, attackers can exploit them. Impact: Attackers can guess or steal backup codes to disable 2FA. Mitigation: Generate backup codes with sufficient complexity (e.g., random alphanumeric strings). Automatically invalidate used codes. Require additional verification (e.g., password input) to use backup codes. Code Example: 123456789101112import secretsimport stringdef generate_backup_code(): return &#x27;&#x27;.join(secrets.choice(string.ascii_letters + string.digits) for _ in range(16))def validate_backup_code(user_id, input_code): stored_code = get_user_backup_code(user_id) if stored_code and input_code == stored_code: invalidate_backup_code(user_id) return True return False 3. Lack of Notification MechanismIf users are not notified when 2FA is disabled, attackers can disable 2FA without the user’s knowledge, leaving accounts exposed. Impact: The legitimate user remains unaware of the security breach. Mitigation: Send real-time notifications (email, SMS, or push) to users whenever 2FA settings are modified. Include information about the device, IP address, and timestamp in the notification. Code Example: 1234567def notify_user(user_id, action): user_email = get_user_email(user_id) send_email( to=user_email, subject=&quot;Security Alert: 2FA Disabled&quot;, message=f&quot;Your 2FA was disabled at &#123;get_current_timestamp()&#125; from IP &#123;get_client_ip()&#125;.&quot; ) 4. Sensitive Operations Lack Additional VerificationSystems often fail to require additional verification (e.g., password input) when disabling 2FA, making it easier for attackers to perform this action if they gain access to the account. Impact: Attackers can easily disable 2FA without the need for additional authentication. Mitigation: Require users to re-enter their password or confirm their identity through another method (e.g., biometric authentication) before disabling 2FA. Code Example: 123456789def verify_password(user_id, input_password): stored_hash = get_user_password_hash(user_id) return check_password_hash(input_password, stored_hash)def disable_2fa_with_verification(user_id, input_password): if verify_password(user_id, input_password): perform_disable_2fa(user_id) else: raise Exception(&quot;Password verification failed.&quot;) 5. Session Token Not Expired After 2FA DisablingIf session tokens are not invalidated after disabling 2FA, attackers can continue using the old session without triggering new authentication. Impact: Attackers with an active session can bypass any changes in authentication settings. Mitigation: Revoke all active sessions after disabling 2FA. Require the user to log in again with updated authentication settings. Code Example: 1234567def revoke_all_sessions(user_id): # Remove all active sessions from the database delete_sessions_for_user(user_id)def disable_2fa(user_id): perform_disable_2fa(user_id) revoke_all_sessions(user_id) 6. CSRF Vulnerabilities in 2FA-Related ActionsCross-Site Request Forgery (CSRF) vulnerabilities can allow attackers to trick authenticated users into disabling 2FA without their knowledge. Impact: Attackers can craft malicious links or forms to disable 2FA on behalf of the user. Mitigation: Use CSRF tokens for all 2FA-related actions. Validate the token server-side for each request. Code Example: 12345678def validate_csrf_token(input_token, session_token): return input_token == session_tokendef disable_2fa(request, user_id): csrf_token = request.get(&quot;csrf_token&quot;) if not validate_csrf_token(csrf_token, get_session_csrf_token(user_id)): raise Exception(&quot;CSRF token validation failed.&quot;) perform_disable_2fa(user_id) 7. Misuse of Developer Debug ModesIn some cases, debug modes allow bypassing 2FA for testing purposes. If left enabled in production, attackers can exploit these debug features. Impact: Attackers can completely bypass 2FA protections. Mitigation: Ensure debug modes are disabled in production builds. Implement runtime checks to verify that debug flags are not present. Code Example: 1234567def ensure_debug_mode_disabled(): if is_debug_mode(): raise Exception(&quot;Debug mode is enabled in production!&quot;)def perform_sensitive_action(): ensure_debug_mode_disabled() # Proceed with action 8. Poorly Configured API PermissionsAPIs that allow 2FA disabling may not properly restrict access. Attackers can exploit misconfigured permissions to disable 2FA via APIs. Impact: Attackers can send unauthorized API requests to disable 2FA. Mitigation: Implement strict authentication and authorization checks for API endpoints. Require API requests to be signed and session-bound. Code Example: 12345def disable_2fa_api(request, user_id): api_token = request.headers.get(&quot;Authorization&quot;) if not validate_api_token(api_token, user_id): raise Exception(&quot;Invalid API token.&quot;) perform_disable_2fa(user_id)","pubDate":"Wed, 05 Feb 2025 12:17:16 GMT","guid":"http://iaaaannn0.com/2025/02/05/From-Setup-to-Exploitation-A-Comprehensive-Guide-to-2FA-Weaknesses/","category":["vuls"]},{"title":"A Comprehensive Guide to Managing Python Projects with Poetry","link":"http://iaaaannn0.com/2025/01/30/poetry/","description":"Poetry is a powerful dependency management and packaging tool for Python. It provides a seamless workflow for managing dependencies, creating virtual environments, and packaging applications. This guide will walk you through the essential features of Poetry, including how to generate a requirements.txt file for compatibility with pip. 1. Installing Poetry To install Poetry, run the following command: 1curl -sSL https://install.python-poetry.org | python3 - After installation, ensure Poetry is available in your terminal by checking its version: 1poetry --version If the command does not work, add Poetry to your PATH: 1export PATH=&quot;$HOME/.local/bin:$PATH&quot; 2. Creating a New Poetry Project To create a new Python project with Poetry, use: 1poetry new my_project This command sets up a basic Python package structure: 123456my_project/├── pyproject.toml # Configuration file for Poetry├── README.rst├── my_project/ # Project source code│ └── __init__.py└── tests/ # Test files If you already have a project and want to initialize Poetry within it, navigate to the project directory and run: 1poetry init This will guide you through setting up pyproject.toml interactively. 3. Managing Dependencies Adding Dependencies To install a package and automatically update pyproject.toml and poetry.lock, use: 1poetry add requests For a development-only dependency: 1poetry add --dev pytest Removing Dependencies To remove a package: 1poetry remove requests Updating Dependencies To update all dependencies: 1poetry update To update a specific package: 1poetry update requests 4. Virtual Environments and Running Code Poetry automatically manages a virtual environment for your project. You can activate it with: 1poetry shell To run a Python script within the virtual environment without activating the shell: 1poetry run python script.py To check the virtual environment being used: 1poetry env info 5. Exporting Requirements for pip Poetry does not use requirements.txt natively, but you can export dependencies for environments that require it (e.g., Docker, CI/CD pipelines). 6. Install the Poetry Export Plugin Poetry 2.0+ requires an additional plugin to export dependencies: 1poetry self add poetry-plugin-export 7. Generate requirements.txt Run the following command to export dependencies: 1poetry export -f requirements.txt --output requirements.txt --without-hashes If you need to include development dependencies: 1poetry export -f requirements.txt --output requirements.txt --without-hashes --with dev You can then install these dependencies using pip: 1pip install -r requirements.txt 8. Version Management To check the current project version: 1poetry version To update the version: 123poetry version patch # Increases 1.0.0 -&gt; 1.0.1poetry version minor # Increases 1.0.0 -&gt; 1.1.0poetry version major # Increases 1.0.0 -&gt; 2.0.0 9. Publishing to PyPI To publish your package to PyPI, first build it: 1poetry build Then publish it: 1poetry publish To publish to TestPyPI for testing: 1poetry publish --repository testpypi Conclusion Poetry simplifies dependency management, virtual environments, and packaging for Python projects. By using Poetry, you can ensure a more reliable and consistent development workflow. With the ability to export requirements.txt, Poetry remains compatible with traditional Python workflows while providing a modern alternative to pip and virtualenv. Start using Poetry today to streamline your Python project management! 🚀","pubDate":"Thu, 30 Jan 2025 04:09:36 GMT","guid":"http://iaaaannn0.com/2025/01/30/poetry/","category":["poetry"]}]}